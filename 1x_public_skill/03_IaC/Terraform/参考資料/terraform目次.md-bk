# Terraform 学習ロードマップ

## ステップ1: 基礎編（初心者向け）

### 1-1. セットアップ

#### 1-1-1. Terraformのインストール
- macOSでのインストール（Homebrew）
- Linuxでのインストール（パッケージマネージャー）
- Windowsでのインストール
- 手動インストール（バイナリダウンロード）
- バージョン管理（tfenv、tfswitch）
- 複数バージョンの管理方法

#### 1-1-2. AWS CLIの設定
- AWS CLIのインストール
- `aws configure`の実行
- アクセスキーとシークレットキーの設定
- リージョンの設定
- プロファイルの作成と切り替え
- 環境変数での認証情報設定
- IAMロールの利用方法

#### 1-1-3. 基本的な環境構築
- 作業ディレクトリの作成
- 初めての`.tf`ファイル作成
- エディタの設定（VSCode拡張機能など）
- シンタックスハイライトの設定
- 自動フォーマットの設定

#### 1-1-4. 開発環境の整備
- Gitリポジトリの初期化
- `.gitignore`の設定
- ディレクトリ構造の理解
- 環境変数の管理方法

### 1-2. 基本操作

#### 1-2-1. terraform init
- 初期化コマンドの基本
- プロバイダーのダウンロード
- バックエンドの初期化
- `.terraform`ディレクトリの理解
- エラーと対処法

#### 1-2-2. terraform plan
- 変更点の確認方法
- plan出力の読み方
- `-out`オプションの使い方
- `-var`オプションでの変数指定
- `-var-file`オプションの使い方
- `-target`オプションでの部分適用
- planの保存と確認

#### 1-2-3. terraform apply
- 変更の反映方法
- 対話的な確認
- `-auto-approve`オプション
- `-var`と`-var-file`の指定
- エラー時の対処法
- ロールバックの方法

#### 1-2-4. terraform destroy
- リソースの削除方法
- 部分的な削除（`-target`オプション）
- 削除の確認方法
- 削除できないリソースの対処

#### 1-2-5. terraform fmt
- コードの自動整形
- 再帰的な整形（`-recursive`）
- 差分の確認（`-check`）
- CI/CDでの活用

#### 1-2-6. terraform validate
- 構文チェックの実行
- バリデーションエラーの読み方
- 変数の型チェック
- リソース参照の検証

#### 1-2-7. その他のコマンド
- `terraform show` - ステートの表示
- `terraform state` - ステート操作
- `terraform output` - 出力値の表示
- `terraform refresh` - ステートの更新
- `terraform graph` - 依存関係の可視化
- `terraform version` - バージョン確認
- `terraform workspace` - ワークスペース操作

### 1-3. 基本構文

#### 1-3-1. リソースの定義
- `resource`ブロックの基本構文
- リソースタイプとリソース名
- リソース属性の設定
- 必須属性とオプション属性
- リソースの命名規則
- リソースの依存関係

#### 1-3-2. プロバイダーの設定
- `provider`ブロックの書き方
- AWSプロバイダーの設定
- リージョンの指定
- 認証情報の設定方法
- 複数プロバイダーの利用
- プロバイダーのバージョン指定

#### 1-3-3. 変数（variable）の使い方
- `variable`ブロックの基本
- 変数の型（string、number、bool、list、map）
- デフォルト値の設定
- 変数の説明（description）
- 変数の検証（validation）
- 変数の参照方法（`var.変数名`）
- 環境変数での変数指定（`TF_VAR_`）

#### 1-3-4. 出力（output）の使い方
- `output`ブロックの基本
- 出力値の定義
- 出力値の参照
- 出力値の表示方法
- 機密情報の非表示（`sensitive = true`）
- 依存関係の明示（`depends_on`）

#### 1-3-5. データソース（data）の使い方
- `data`ブロックの基本
- 既存リソースの参照
- データソースの種類
- データソースのフィルタリング
- データソースの依存関係

#### 1-3-6. localsの活用
- `locals`ブロックの基本
- ローカル変数の定義
- 計算式の使用
- 複雑な値の簡略化
- localsとvariableの使い分け

#### 1-3-7. ファイルの読み込み
- `file()`関数の使い方
- テンプレートファイルの読み込み
- 外部ファイルの参照方法

#### 1-3-8. コメントの書き方
- 単行コメント（`#`）
- 複数行コメント（`/* */`）
- ドキュメントコメントのベストプラクティス

## ステップ2: 実践編（AWSリソース構築）

### 2-1. 全体設計

#### 2-1-1. プロジェクト構造の設計
- モノリシック構造 vs モジュール構造
- 環境ごとの分離方法
- リソースのグループ化
- ディレクトリ命名規則

#### 2-1-2. ディレクトリ構成
- 基本的なディレクトリ構造
- `modules/`ディレクトリの活用
- `environments/`ディレクトリの設計
- `scripts/`ディレクトリの配置
- 設定ファイル（`.tfvars`）の配置

#### 2-1-3. 命名規則
- リソース名の命名規則
- 変数名の命名規則
- モジュール名の命名規則
- タグの命名規則
- AWSリソース名の制約

#### 2-1-4. ファイル構成
- `main.tf`の役割
- `variables.tf`の役割
- `outputs.tf`の役割
- `terraform.tfvars`の使い方
- `versions.tf`でのバージョン固定

### 2-2. 権限管理

#### 2-2-1. IAMの基礎
- IAMユーザーの作成
- IAMグループの作成
- IAMロールの作成
- IAMポリシーの作成

#### 2-2-2. IAMロール・ポリシーの作成
- インスタンスプロファイルの作成
- サービスロールの作成
- カスタムポリシーの作成
- インラインポリシー vs マネージドポリシー
- ポリシードキュメントの書き方

#### 2-2-3. タスクロールとタスク実行ロール
- ECSタスクロールの作成
- ECSタスク実行ロールの作成
- ロールの使い分け
- 最小権限の原則

#### 2-2-4. クロスアカウントアクセス
- クロスアカウントロールの設定
- AssumeRoleの設定
- 外部IDの利用

#### 2-2-5. IAMベストプラクティス
- 最小権限の原則
- ポリシーのテスト方法
- 権限の監査方法

### 2-3. ストレージ

#### 2-3-1. S3バケットの作成
- バケットの基本作成
- バケット名の制約
- バージョニングの有効化
- ライフサイクルポリシーの設定
- 暗号化の設定（SSE-S3、SSE-KMS）
- パブリックアクセスのブロック
- CORS設定
- バケットポリシーの設定
- 静的ウェブサイトホスティング

#### 2-3-2. S3オブジェクトの管理
- オブジェクトのアップロード
- オブジェクトのアクセス制御
- プリサインドURLの生成

#### 2-3-3. EBSボリュームの作成
- EBSボリュームの基本作成
- ボリュームタイプの選択（gp3、io1、io2）
- サイズの指定
- 暗号化の設定
- スナップショットの作成
- ボリュームのアタッチ

#### 2-3-4. EFSファイルシステムの作成
- EFSファイルシステムの基本作成
- パフォーマンスモードの選択
- スループットモードの選択
- マウントターゲットの作成
- アクセスポイントの作成
- バックアップポリシーの設定

#### 2-3-5. FSxの作成
- FSx for Windows File Server
- FSx for Lustre
- FSx for NetApp ONTAP

### 2-4. ネットワーク

#### 2-4-1. VPCの作成
- VPCの基本作成
- CIDRブロックの設計
- IPv6の有効化
- DNS設定
- DHCPオプションセット

#### 2-4-2. サブネットの作成
- パブリックサブネットの作成
- プライベートサブネットの作成
- サブネットのCIDR設計
- アベイラビリティゾーンの分散
- サブネットのタグ付け

#### 2-4-3. インターネットゲートウェイ（IGW）
- IGWの作成とアタッチ
- ルートテーブルへの追加
- パブリックサブネットの設定

#### 2-4-4. NATゲートウェイ
- NATゲートウェイの作成
- プライベートサブネットからのインターネット接続
- 高可用性の確保（複数AZ）
- コスト最適化の考慮

#### 2-4-5. セキュリティグループ
- セキュリティグループの基本作成
- インバウンドルールの設定
- アウトバウンドルールの設定
- セキュリティグループ間の参照
- セキュリティグループの再利用

#### 2-4-6. ネットワークACL
- ネットワークACLの作成
- ルールの設定
- セキュリティグループとの違い

#### 2-4-7. ルートテーブル
- ルートテーブルの作成
- ルートの追加
- サブネットへの関連付け
- デフォルトルートテーブル

#### 2-4-8. VPCエンドポイント
- Gatewayエンドポイント（S3、DynamoDB）
- Interfaceエンドポイント
- エンドポイントポリシー

#### 2-4-9. VPCピアリング
- VPCピアリング接続の作成
- ルートテーブルの設定
- セキュリティグループの設定

#### 2-4-10. Transit Gateway
- Transit Gatewayの作成
- VPCアタッチメント
- ルートテーブルの設定

### 2-5. ロードバランサーとDNS

#### 2-5-1. Application Load Balancer（ALB）
- ALBの基本作成
- リスナーの設定
- ターゲットグループの作成
- ヘルスチェックの設定
- SSL/TLS証明書の設定（ACM）
- リダイレクトルールの設定
- 固定レスポンスの設定
- 認証の設定（Cognito、OIDC）

#### 2-5-2. Network Load Balancer（NLB）
- NLBの基本作成
- ターゲットグループの作成
- ヘルスチェックの設定
- 静的IPアドレスの設定

#### 2-5-3. Classic Load Balancer（CLB）
- CLBの基本作成（レガシー）
- 使用ケースの理解

#### 2-5-4. Route 53の設定
- ホストゾーンの作成
- Aレコードの作成
- CNAMEレコードの作成
- ALIASレコードの作成
- ヘルスチェックの設定
- フェイルオーバールーティング
- 地理的位置ベースルーティング
- レイテンシーベースルーティング
- 重み付けルーティング

#### 2-5-5. CloudFront
- CloudFrontディストリビューションの作成
- オリジンの設定
- キャッシュビヘイビアの設定
- SSL/TLS証明書の設定
- カスタムドメインの設定

### 2-6. コンテナオーケストレーション

#### 2-6-1. ECSクラスターの作成
- ECSクラスターの基本作成
- クラスター設定のカスタマイズ
- クラスターの容量プロバイダー

#### 2-6-2. ECS on Fargate
- Fargateタスク定義の作成
- タスクサイズの設定（CPU、メモリ）
- コンテナ定義の設定
- 環境変数の設定
- シークレットの設定
- ログ設定（CloudWatch Logs）
- ネットワーク設定
- タスクロールとタスク実行ロール

#### 2-6-3. ECS on EC2
- EC2インスタンスの起動設定
- オートスケーリンググループの設定
- クラスターへの登録
- タスクの配置戦略

#### 2-6-4. ECSサービス
- ECSサービスの作成
- サービスのデプロイ設定
- サービスのオートスケーリング
- ヘルスチェックの設定
- ロードバランサーとの統合

#### 2-6-5. ECRリポジトリの作成
- ECRリポジトリの作成
- ライフサイクルポリシーの設定
- イメージスキャンの設定
- リポジトリポリシーの設定
- イメージのプッシュとプル

#### 2-6-6. EKS（Elastic Kubernetes Service）
- EKSクラスターの作成
- ノードグループの作成
- Fargateプロファイルの設定
- アドオンの設定

### 2-7. バッチ

#### 2-7-1. ECSタスクの作成
- ワンオフタスクの実行
- タスク定義の作成
- タスクの起動方法

#### 2-7-2. バッチ処理の設定
- EventBridgeでのスケジュール実行
- Step Functionsとの連携
- バッチ処理のモニタリング

#### 2-7-3. AWS Batch
- コンピューティング環境の作成
- ジョブキューの作成
- ジョブ定義の作成
- ジョブの送信

### 2-8. 鍵管理

#### 2-8-1. KMSキーの作成
- カスタマーマネージドキー（CMK）の作成
- キーポリシーの設定
- キーの有効化/無効化
- キーのローテーション
- エイリアスの作成
- キーの削除保護

#### 2-8-2. Secrets Managerの設定
- シークレットの作成
- シークレットの取得
- シークレットのローテーション
- Lambda関数での自動ローテーション
- シークレットの参照方法

#### 2-8-3. Parameter Storeの利用
- パラメータの作成
- 標準パラメータ vs 高度なパラメータ
- パラメータの暗号化
- パラメータの階層構造
- パラメータの参照方法

### 2-9. 設定管理

#### 2-9-1. Systems Manager（SSM）の設定
- SSMドキュメントの作成
- SSMパラメータストアの利用
- SSMパッチマネージャー
- SSMメンテナンスウィンドウ

#### 2-9-2. Session Manager
- Session Managerの設定
- IAMロールの設定
- VPCエンドポイントの設定
- セッションログの設定

#### 2-9-3. Systems Manager Automation
- 自動化ドキュメントの作成
- 自動化の実行

### 2-10. データストア

#### 2-10-1. RDSの作成
- RDSインスタンスの基本作成
- エンジンの選択（MySQL、PostgreSQL、MariaDB、Oracle、SQL Server）
- インスタンスクラスの選択
- ストレージの設定
- マルチAZの設定
- バックアップの設定
- スナップショットの作成
- パラメータグループの作成
- オプショングループの設定
- セキュリティグループの設定
- サブネットグループの作成
- 読み取りレプリカの作成

#### 2-10-2. Auroraの作成
- Auroraクラスターの作成
- クラスターエンドポイントの設定
- 読み取りエンドポイントの設定
- サーバーレスv2の設定
- グローバルデータベースの設定

#### 2-10-3. DynamoDBテーブルの作成
- テーブルの基本作成
- パーティションキーとソートキーの設計
- グローバルセカンダリインデックス（GSI）
- ローカルセカンダリインデックス（LSI）
- オンデマンド vs プロビジョンドキャパシティ
- オートスケーリングの設定
- TTLの設定
- ストリームの有効化
- バックアップの設定
- ポイントインタイムリカバリー（PITR）

#### 2-10-4. ElastiCacheの設定
- Redisクラスターの作成
- Memcachedクラスターの作成
- パラメータグループの設定
- サブネットグループの作成
- スナップショットの設定

#### 2-10-5. DocumentDB
- DocumentDBクラスターの作成
- インスタンスの設定
- バックアップの設定

#### 2-10-6. Neptune
- Neptuneクラスターの作成
- インスタンスの設定

#### 2-10-7. Redshift
- Redshiftクラスターの作成
- ノードタイプの選択
- スナップショットの設定

### 2-11. コンピューティング

#### 2-11-1. EC2インスタンス
- EC2インスタンスの基本作成
- インスタンスタイプの選択
- AMIの選択
- キーペアの設定
- セキュリティグループの設定
- ユーザーデータの設定
- IAMロールのアタッチ
- EBSボリュームのアタッチ
- タグの設定

#### 2-11-2. オートスケーリング
- 起動テンプレートの作成
- オートスケーリンググループの作成
- スケーリングポリシーの設定
- ヘルスチェックの設定
- ライフサイクルフックの設定

#### 2-11-3. Lambda関数
- Lambda関数の基本作成
- ランタイムの選択
- ハンドラーの設定
- 環境変数の設定
- メモリとタイムアウトの設定
- IAMロールの設定
- VPC設定
- デッドレターキュー（DLQ）の設定
- イベントソースマッピング
- Lambdaレイヤーの作成

#### 2-11-4. API Gateway
- REST APIの作成
- リソースとメソッドの定義
- 統合の設定（Lambda、HTTP、Mock）
- デプロイステージの作成
- カスタムドメインの設定
- APIキーの設定
- 使用量プランの設定
- 認証の設定（Cognito、Lambda Authorizer）

### 2-12. モニタリングとロギング

#### 2-12-1. CloudWatch
- CloudWatchアラームの作成
- メトリクスの監視
- ダッシュボードの作成
- カスタムメトリクスの送信

#### 2-12-2. CloudWatch Logs
- ロググループの作成
- ログストリームの作成
- ログ保持期間の設定
- ログフィルターの設定
- メトリクスフィルターの作成
- サブスクリプションフィルターの設定

#### 2-12-3. CloudTrail
- CloudTrailの有効化
- ログファイルの保存先（S3）
- イベントセレクターの設定
- データイベントの記録

#### 2-12-4. X-Ray
- X-Rayトレーシングの有効化
- サンプリングルールの設定

### 2-13. セキュリティ

#### 2-13-1. WAF（Web Application Firewall）
- WAF Web ACLの作成
- ルールの設定
- レート制限の設定
- IPセットの作成
- 地理的ブロッキング

#### 2-13-2. Shield
- Shield Standard（自動有効）
- Shield Advancedの設定

#### 2-13-3. GuardDuty
- GuardDutyの有効化
- 検出結果の通知設定

#### 2-13-4. Security Hub
- Security Hubの有効化
- セキュリティ標準の有効化

#### 2-13-5. Inspector
- Inspectorの有効化
- 評価テンプレートの作成

### 2-14. コスト管理

#### 2-14-1. Cost Explorer
- コスト分析の設定
- 予算の設定

#### 2-14-2. タグ戦略
- コスト配分タグの設定
- タグポリシーの設定

### 2-15. その他のサービス

#### 2-15-1. SNS（Simple Notification Service）
- トピックの作成
- サブスクリプションの作成
- メッセージの送信

#### 2-15-2. SQS（Simple Queue Service）
- キューの作成
- デッドレターキューの設定
- メッセージの送受信

#### 2-15-3. EventBridge
- ルールの作成
- イベントパターンの設定
- ターゲットの設定

#### 2-15-4. Step Functions
- ステートマシンの作成
- ワークフローの定義
- エラーハンドリング

#### 2-15-5. Cognito
- ユーザープールの作成
- IDプールの作成
- 認証フローの設定

#### 2-15-6. CodeCommit
- リポジトリの作成
- ブランチの保護設定

#### 2-15-7. CodeBuild
- プロジェクトの作成
- ビルド仕様の設定

#### 2-15-8. CodeDeploy
- アプリケーションの作成
- デプロイメントグループの作成

#### 2-15-9. CodePipeline
- パイプラインの作成
- ステージの設定
- アクションの設定

## ステップ3: 運用編

### 3-1. デプロイメントパイプライン

#### 3-1-1. CI/CDパイプラインとの連携
- GitHub Actionsとの連携
- GitLab CI/CDとの連携
- Jenkinsとの連携
- CircleCIとの連携
- パイプラインの設計

#### 3-1-2. CodePipeline、CodeBuildとの統合
- CodePipelineパイプラインの作成
- CodeBuildプロジェクトの作成
- Terraformのビルド仕様
- デプロイステージの設定
- 承認ステップの追加

#### 3-1-3. デプロイ戦略
- ブルー・グリーンデプロイ
- カナリアデプロイ
- ロールバック戦略
- デプロイ前の検証

#### 3-1-4. 環境管理
- 開発環境の管理
- ステージング環境の管理
- 本番環境の管理
- 環境間の差分管理

### 3-2. SSHレスオペレーション

#### 3-2-1. Systems Manager Session Managerの利用
- Session Managerの設定
- IAMロールの設定
- VPCエンドポイントの設定
- セッションログの設定
- ポートフォワーディング

#### 3-2-2. EC2インスタンスへの接続
- セッションの開始方法
- コマンドの実行
- ファイルの転送

#### 3-2-3. Systems Manager Run Command
- コマンドドキュメントの利用
- 複数インスタンスへのコマンド実行
- コマンド履歴の確認

### 3-3. ロギング

#### 3-3-1. CloudWatch Logsの設定
- ロググループの作成
- ログストリームの設定
- ログ保持期間の設定
- ログのエクスポート（S3、Kinesis）

#### 3-3-2. ログの集約と監視
- ログの集約方法
- ログフィルターの設定
- メトリクスフィルターの作成
- アラームの設定

#### 3-3-3. 構造化ログ
- JSON形式のログ
- ログパーサーの設定

#### 3-3-4. ログ分析
- CloudWatch Logs Insights
- Athenaでのログ分析
- Elasticsearchへの送信

### 3-4. バックアップとリカバリー

#### 3-4-1. バックアップ戦略
- EBSスナップショット
- RDSスナップショット
- S3バージョニング
- バックアップの自動化

#### 3-4-2. リカバリー手順
- スナップショットからの復元
- クロスリージョンコピー
- ディザスタリカバリー計画

### 3-5. パフォーマンス最適化

#### 3-5-1. リソースの最適化
- インスタンスタイプの選択
- ストレージの最適化
- ネットワークの最適化

#### 3-5-2. コスト最適化
- リザーブドインスタンス
- スポットインスタンス
- Savings Plans
- 未使用リソースの削除

### 3-6. セキュリティ運用

#### 3-6-1. セキュリティパッチの適用
- Systems Manager Patch Manager
- パッチベースラインの設定
- メンテナンスウィンドウ

#### 3-6-2. 脆弱性スキャン
- Inspectorの実行
- セキュリティグループの監査
- コンプライアンスチェック

#### 3-6-3. アクセス管理
- IAMポリシーの監査
- アクセスログの確認
- 最小権限の原則の適用

## ステップ4: ベストプラクティス編

### 4-1. Terraformベストプラクティス

#### 4-1-1. コードの可読性
- 一貫したフォーマット（`terraform fmt`）
- 意味のある変数名とリソース名
- 適切なコメントの追加
- ファイルの分割方法
- コードの構造化

#### 4-1-2. 変数の活用
- ハードコードの回避
- デフォルト値の設定
- 変数の検証
- 環境変数の活用
- `.tfvars`ファイルの活用

#### 4-1-3. モジュールの活用
- 再利用可能なモジュールの作成
- モジュールのパラメータ化
- モジュールのバージョン管理
- 公開モジュールの利用

#### 4-1-4. コメントの書き方
- ドキュメントコメント
- 複雑なロジックの説明
- TODOコメント
- 非推奨の明示

#### 4-1-5. エラーハンドリング
- バリデーションの追加
- エラーメッセージの改善
- 失敗時の挙動の設計

#### 4-1-6. パフォーマンス
- 並列実行の最適化
- 依存関係の最適化
- データソースの効率的な使用

### 4-2. AWSベストプラクティス

#### 4-2-1. セキュリティのベストプラクティス
- 最小権限の原則
- セキュリティグループの適切な設定
- 暗号化の有効化
- パブリックアクセスの制限
- ログの有効化
- セキュリティパッチの適用

#### 4-2-2. コスト最適化
- 適切なリソースサイズの選択
- 未使用リソースの削除
- リザーブドインスタンスの活用
- スポットインスタンスの活用
- タグによるコスト管理

#### 4-2-3. パフォーマンス最適化
- 適切なインスタンスタイプの選択
- キャッシュの活用
- CDNの活用
- データベースの最適化
- ネットワークの最適化

#### 4-2-4. 可用性と信頼性
- マルチAZの配置
- オートスケーリングの設定
- ヘルスチェックの設定
- バックアップの自動化
- ディザスタリカバリー計画

#### 4-2-5. 運用のベストプラクティス
- モニタリングとアラート
- ログの集約
- 変更管理プロセス
- ドキュメントの整備

## ステップ5: 上級編

### 5-1. 高度な構文

#### 5-1-1. 条件分岐
- `count`による条件付きリソース作成
- `for_each`による条件付きリソース作成
- `count`と`for_each`の使い分け
- 三項演算子の活用
- `if`条件の実装

#### 5-1-2. ループ処理
- `for`式の基本
- `for_each`でのループ
- `count`でのループ
- ネストされたループ
- ループでの条件分岐

#### 5-1-3. 動的なリソース作成
- 動的なリソース名
- 動的な属性値
- マップとリストの活用
- 変数の動的な組み合わせ

#### 5-1-4. localsの活用
- 複雑な計算式の簡略化
- 繰り返し使用する値の定義
- localsでの条件分岐
- localsでのループ処理

#### 5-1-5. 関数の活用
- 文字列関数（`join`、`split`、`replace`など）
- 数値関数（`max`、`min`、`abs`など）
- コレクション関数（`keys`、`values`、`merge`など）
- 日付・時刻関数
- 暗号化関数
- 型変換関数

#### 5-1-6. テンプレート
- `templatefile()`関数
- テンプレート変数
- 条件付きテンプレート

### 5-2. tfstateファイルの管理

#### 5-2-1. ステートファイルの理解
- ステートファイルの構造
- ステートファイルの役割
- ステートファイルの読み方
- ステートファイルの編集（非推奨）

#### 5-2-2. リモートバックエンド
- ローカルバックエンド vs リモートバックエンド
- S3バックエンドの設定
- DynamoDBでのステートロック
- バックエンドの移行方法
- バックエンドの設定パラメータ

#### 5-2-3. ステートファイルのロック
- ロックの仕組み
- ロックの解除方法
- ロックの競合解決

#### 5-2-4. ステートファイルの共有
- チームでのステート共有
- ステートファイルのバックアップ
- ステートファイルのバージョン管理

#### 5-2-5. ステート操作
- `terraform state list` - リソース一覧
- `terraform state show` - リソース詳細
- `terraform state mv` - リソースの移動
- `terraform state rm` - リソースの削除
- `terraform state pull/push` - ステートの取得/送信

### 5-3. 構造化

#### 5-3-1. ディレクトリ構造の最適化
- モノリシック構造
- モジュール構造
- 環境ごとの分離
- サービスごとの分離

#### 5-3-2. 環境ごとの分離（dev、staging、prod）
- 環境ごとのディレクトリ
- 環境ごとの変数ファイル
- 環境ごとのバックエンド
- 環境間の差分管理

#### 5-3-3. ワークスペースの活用
- ワークスペースの作成
- ワークスペースの切り替え
- ワークスペースごとの変数
- ワークスペースの制限事項

#### 5-3-4. モジュール構造
- ルートモジュール
- 子モジュール
- モジュールの階層構造
- モジュールの呼び出し

### 5-4. モジュール設計

#### 5-4-1. モジュールの作成
- モジュールの基本構造
- モジュールの入力変数
- モジュールの出力値
- モジュールの依存関係

#### 5-4-2. モジュールの再利用
- モジュールの呼び出し
- モジュールのパラメータ化
- モジュールのバージョン指定
- モジュールのテスト

#### 5-4-3. モジュールの公開
- Terraform Registryへの公開
- プライベートレジストリの構築
- モジュールのドキュメント化
- モジュールのバージョン管理

#### 5-4-4. モジュールのベストプラクティス
- 単一責任の原則
- 適切な抽象化レベル
- 柔軟性と使いやすさのバランス
- モジュールのテスト方法

### 5-5. リソース参照パターン

#### 5-5-1. リソース間の依存関係
- 暗黙的な依存関係
- 明示的な依存関係（`depends_on`）
- 依存関係の最適化
- 循環依存の回避

#### 5-5-2. データソースの活用
- 既存リソースの参照
- データソースでのフィルタリング
- データソースの条件分岐
- データソースのパフォーマンス

#### 5-5-3. リモートステートの参照
- `terraform_remote_state`データソース
- リモートステートの参照方法
- ステートファイルの分離
- ステートファイル間の依存関係

#### 5-5-4. クロスモジュール参照
- モジュール間のデータ共有
- 出力値の活用
- 変数の受け渡し

### 5-6. リファクタリング

#### 5-6-1. コードの整理
- 重複コードの排除
- 関数の抽出
- 変数の統合
- ファイルの分割

#### 5-6-2. 重複の排除
- DRY原則の適用
- モジュールの活用
- 共通設定の抽出

#### 5-6-3. パフォーマンスの改善
- 並列実行の最適化
- 依存関係の最適化
- データソースの最適化
- ステートファイルのサイズ削減

#### 5-6-4. リファクタリングの手順
- 計画の作成
- 段階的な移行
- テストの実施
- ロールバック計画

### 5-7. 既存リソースのインポート

#### 5-7-1. `terraform import`の使い方
- インポートコマンドの基本
- リソースIDの指定
- インポート後の設定
- インポートの検証

#### 5-7-2. 既存インフラのTerraform化
- インポート戦略の立案
- 大量リソースのインポート
- インポートスクリプトの作成
- インポート後のリファクタリング

#### 5-7-3. インポートのベストプラクティス
- 段階的なインポート
- バックアップの取得
- テスト環境での検証
- ドキュメントの更新

### 5-8. チーム開発

#### 5-8-1. コードレビューの方法
- レビューチェックリスト
- セキュリティレビュー
- パフォーマンスレビュー
- ベストプラクティスの確認

#### 5-8-2. ブランチ戦略
- Git Flow
- GitHub Flow
- GitLab Flow
- ブランチ命名規則

#### 5-8-3. コンフリクトの解決
- ステートファイルのコンフリクト
- コードのコンフリクト
- マージ戦略
- コンフリクトの予防

#### 5-8-4. コラボレーションツール
- Terraform Cloud
- Terraform Enterprise
- プルリクエストの活用
- CI/CDの統合

### 5-9. 継続的Apply

#### 5-9-1. 自動化の実装
- CI/CDパイプラインの構築
- 自動Applyの設定
- 承認フローの実装
- 通知の設定

#### 5-9-2. エラーハンドリング
- エラーの検出
- エラーログの記録
- アラートの設定
- 自動ロールバック

#### 5-9-3. ロールバック戦略
- ロールバックの方法
- スナップショットの活用
- バージョン管理
- ロールバックの自動化

#### 5-9-4. ガバナンス
- ポリシーの適用
- コンプライアンスチェック
- コスト管理
- セキュリティスキャン

## ステップ6: 実践プロジェクト

### 6-1. シンプルなWebアプリケーションの構築

#### 6-1-1. アーキテクチャ設計
- EC2 + ALB + RDSの構成
- ネットワーク設計
- セキュリティ設計
- 可用性の確保

#### 6-1-2. 実装手順
- VPCとネットワークの構築
- セキュリティグループの設定
- EC2インスタンスの作成
- ALBの設定
- RDSの作成
- アプリケーションのデプロイ

#### 6-1-3. モニタリングとロギング
- CloudWatchの設定
- アラームの設定
- ログの集約

#### 6-1-4. セキュリティ強化
- WAFの設定
- SSL/TLS証明書の設定
- セキュリティグループの最適化

### 6-2. コンテナベースのアプリケーション

#### 6-2-1. アーキテクチャ設計
- ECS on Fargate + ALBの構成
- コンテナイメージの管理
- サービスディスカバリー

#### 6-2-2. 実装手順
- ECRリポジトリの作成
- コンテナイメージのプッシュ
- ECSクラスターの作成
- タスク定義の作成
- ECSサービスの作成
- ALBとの統合

#### 6-2-3. CI/CDパイプライン
- イメージビルドの自動化
- デプロイの自動化
- ロールバックの実装

#### 6-2-4. スケーリング
- オートスケーリングの設定
- キャパシティプロバイダーの設定
- スケーリングポリシーの調整

### 6-3. サーバーレスアプリケーション

#### 6-3-1. アーキテクチャ設計
- Lambda + API Gateway + DynamoDBの構成
- イベント駆動アーキテクチャ
- マイクロサービス設計

#### 6-3-2. 実装手順
- DynamoDBテーブルの作成
- Lambda関数の作成
- API Gatewayの設定
- 統合の実装
- 認証の設定

#### 6-3-3. イベント処理
- EventBridgeの設定
- SQS/SNSとの連携
- 非同期処理の実装

#### 6-3-4. モニタリングとデバッグ
- X-Rayトレーシング
- CloudWatch Logs
- エラーハンドリング

### 6-4. マルチリージョン構成

#### 6-4-1. グローバルアプリケーション
- Route 53でのルーティング
- CloudFrontでの配信
- リージョン間のレプリケーション

#### 6-4-2. ディザスタリカバリー
- バックアップリージョンの設定
- フェイルオーバーの実装
- データのレプリケーション

### 6-5. ハイブリッドクラウド

#### 6-5-1. オンプレミスとの接続
- VPN接続の設定
- Direct Connectの設定
- ハイブリッドネットワークの構築

#### 6-5-2. 統合管理
- オンプレミスリソースの管理
- クラウドリソースとの統合

### 6-6. マイクロサービスアーキテクチャ

#### 6-6-1. サービス分離
- サービスごとのモジュール
- サービス間の通信
- サービスディスカバリー

#### 6-6-2. デプロイメント戦略
- ブルー・グリーンデプロイ
- カナリアデプロイ
- 段階的ロールアウト

## ステップ7: テストと品質保証

### 7-1. Terraformのテスト

#### 7-1-1. バリデーションテスト
- `terraform validate`
- 構文チェック
- 型チェック

#### 7-1-2. プランテスト
- `terraform plan`の検証
- 変更内容の確認
- 予期しない変更の検出

#### 7-1-3. ユニットテスト
- Terratestの活用
- モジュールのテスト
- 関数のテスト

#### 7-1-4. 統合テスト
- 実際のリソース作成
- エンドツーエンドテスト
- クリーンアップの自動化

### 7-2. セキュリティテスト

#### 7-2-1. セキュリティスキャン
- Checkovの活用
- TFLintの活用
- セキュリティポリシーの適用

#### 7-2-2. コンプライアンスチェック
- ポリシーの検証
- ベストプラクティスの確認
- 規制要件の遵守

### 7-3. パフォーマンステスト

#### 7-3-1. 実行時間の測定
- Plan時間の最適化
- Apply時間の最適化
- 並列実行の確認

#### 7-3-2. リソース使用量
- メモリ使用量
- CPU使用量
- ネットワーク使用量

## ステップ8: トラブルシューティング

### 8-1. よくあるエラーと対処法

#### 8-1-1. プロバイダーエラー
- 認証エラー
- リージョンエラー
- バージョン互換性エラー

#### 8-1-2. リソースエラー
- リソース作成エラー
- リソース更新エラー
- リソース削除エラー

#### 8-1-3. ステートエラー
- ステートファイルの破損
- ステートファイルのロック
- ステートファイルの不一致

#### 8-1-4. 構文エラー
- HCL構文エラー
- 変数参照エラー
- 型エラー

### 8-2. デバッグ方法

#### 8-2-1. ログの確認
- Terraformのログレベル
- デバッグログの有効化
- ログの解析

#### 8-2-2. ステートの確認
- ステートファイルの確認
- リソースの状態確認
- 依存関係の確認

#### 8-2-3. プランの詳細確認
- プラン出力の詳細分析
- 変更内容の確認
- 予期しない変更の検出

### 8-3. パフォーマンスチューニング

#### 8-3-1. 実行時間の短縮
- 並列実行の最適化
- 依存関係の最適化
- データソースの最適化

#### 8-3-2. メモリ使用量の削減
- ステートファイルのサイズ削減
- リソースの最適化
- モジュールの最適化

#### 8-3-3. ネットワーク最適化
- プロバイダーの最適化
- API呼び出しの最適化
- リトライポリシーの調整

## 補足・参考

### 落ち穂拾い

#### よくあるエラーと対処法
- エラーメッセージの読み方
- エラーの分類
- 対処法の選択
- 予防策

#### トラブルシューティング
- 問題の特定方法
- ログの確認方法
- コミュニティでの質問方法

#### パフォーマンスチューニング
- ボトルネックの特定
- 最適化の実施
- ベンチマークの実施

#### よくある質問（FAQ）
- 初心者向けQ&A
- 中級者向けQ&A
- 上級者向けQ&A

### 参考資料

#### 公式ドキュメント
- Terraform公式ドキュメント
- AWS Providerドキュメント
- HashiCorp Learn

#### コミュニティリソース
- Terraform Registry
- GitHubリポジトリ
- ブログ記事
- 動画チュートリアル

#### 学習コンテンツ
- オンラインコース
- 書籍
- ハンズオンラボ
- サンプルコード

#### ツールとエコシステム
- Terraform Cloud
- Terraform Enterprise
- サードパーティツール
- IDE拡張機能

### 用語集

#### Terraform用語
- リソース、プロバイダー、モジュール
- ステート、バックエンド、ワークスペース
- 変数、出力、データソース

#### AWS用語
- リージョン、アベイラビリティゾーン
- VPC、サブネット、セキュリティグループ
- IAM、ロール、ポリシー

### チェックリスト

#### プロジェクト開始時
- 環境のセットアップ
- プロジェクト構造の設計
- バックエンドの設定
- バージョン管理の設定

#### 開発時
- コードレビュー
- テストの実施
- ドキュメントの更新
- セキュリティチェック

#### デプロイ時
- プランの確認
- バックアップの取得
- ロールバック計画
- モニタリングの設定

#### 運用時
- 定期的なレビュー
- セキュリティパッチの適用
- コストの監視
- パフォーマンスの監視
